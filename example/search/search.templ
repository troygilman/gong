package search

import (
	"github.com/troygilman/gong"
	"github.com/troygilman/gong/component"
	"github.com/troygilman/gong/form"
	"github.com/troygilman/gong/hooks"
	"github.com/troygilman/gong/route"
	"net/http"
	"strings"
)

func Route() gong.Route {
	return route.New("/", component.New(SearchComponent{
		names: []string{
			"Sam Goodwill",
			"Chris Evans",
			"John Smith",
			"Jack Williams",
			"May Flower",
		},
	}))
}

type SearchComponent struct {
	names []string
}

templ (c SearchComponent) View() {
	@form.New() {
		<input
			type="search"
			name="name"
			list="options"
			autocomplete="off"
			hx-get
			hx-headers={ hooks.ActionHeaders(ctx) }
			hx-target="#options"
			hx-swap={ gong.SwapOuterHTML }
			hx-trigger="input changed delay:200ms"
		/>
		@searchOptions([]string{})
	}
	<div id={ hooks.ComponentID(ctx) }></div>
}

templ (c SearchComponent) Action() {
	switch hooks.Request(ctx).Method {
		case http.MethodGet:
			{{
			queryName := hooks.QueryParam(ctx, "name")
			queryName = strings.ToLower(queryName)
			matches := []string{}
			if queryName != "" {
				for _, name := range c.names {
					if strings.Contains(strings.ToLower(name), queryName) {
						matches = append(matches, name)
					}
				}
			}
			}}
			@searchOptions(matches)
		case http.MethodPost:
			{{
				queryName := hooks.FormValue(ctx, "name")
			}}
			{ queryName }
	}
}

templ searchOptions(options []string) {
	<datalist id="options">
		for _, name := range options {
			<option value={ name }></option>
		}
	</datalist>
}
