package outlet

import (
	"context"
	"github.com/troygilman/gong"
	"github.com/troygilman/gong/hooks"
	"github.com/troygilman/gong/internal/gctx"
	"github.com/troygilman/gong/internal/util"
	"io"
	"strconv"
)

// NewOutlet creates a new Outlet instance.
// The outlet will automatically render child routes based on the current path.
templ New(opts ...Option) {
	{{
		c := Config{}
		for _, opt := range opts {
			c = opt(c)
		}
	}}
	<div
		id={ hooks.OutletID(ctx) }
		if c.oob {
			hx-swap-oob={ gong.SwapInnerHTML }
		}
		if c.classes != nil {
			class={ c.classes }
		}
		{ c.attrs... }
	>
		@templ.ComponentFunc(func(ctx context.Context, w io.Writer) error {
			gCtx := gctx.GetContext(ctx)
			if child := gCtx.Route.Child(gCtx.ChildRouteIndex); child != nil {
				gCtx.CurrentRouteID += strconv.Itoa(gCtx.ChildRouteIndex)
				gCtx.Depth++
				return util.Render(ctx, gCtx, w, child)
			}
			return nil
		})
	</div>
}

// Outlet represents a container component that renders child routes.
// It serves as a dynamic content area where route components are rendered
// based on the current URL path. Outlets are essential for nested routing.
type Config struct {
	oob     bool
	attrs   templ.Attributes
	classes templ.CSSClasses
}

type Option func(Config) Config

func WithAttrs(attrs templ.Attributes) Option {
	return func(c Config) Config {
		c.attrs = attrs
		return c
	}
}

func WithOOB(oob bool) Option {
	return func(c Config) Config {
		c.oob = oob
		return c
	}
}

func WithClasses(classes ...any) Option {
	return func(c Config) Config {
		c.classes = templ.Classes(classes...)
		return c
	}
}
